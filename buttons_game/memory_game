#define BUTTON_RED   18
#define BUTTON_BLUE  19
#define BUTTON_GREEN 21
#define LED_PIN      2    // External LED connected to GPIO 2

const int SEQUENCE_LENGTH = 6;
int colorSequence[SEQUENCE_LENGTH];
int currentStep = 0;
bool gameActive = true;

int lastButtonState[3] = {HIGH, HIGH, HIGH};
const unsigned long debounceDelay = 300;
unsigned long lastDebounceTime[3] = {0, 0, 0};

void setup() {
  Serial.begin(9600);
  delay(2000); // Wait for Serial Monitor to connect

  pinMode(BUTTON_RED, INPUT_PULLUP);
  pinMode(BUTTON_BLUE, INPUT_PULLUP);
  pinMode(BUTTON_GREEN, INPUT_PULLUP);
  pinMode(LED_PIN, OUTPUT);

  randomSeed(analogRead(0));

  // Generate random sequence from a large pool, then mod 3
  for (int i = 0; i < SEQUENCE_LENGTH; i++) {
    int randNum = random(0, 10000); // Large pool
    colorSequence[i] = randNum % 3; // Map to 0, 1, or 2
  }

  Serial.print("Generated color sequence: ");
  for (int i = 0; i < SEQUENCE_LENGTH; i++) {
    switch (colorSequence[i]) {
      case 0: Serial.print("Red "); break;
      case 1: Serial.print("Blue "); break;
      case 2: Serial.print("Green "); break;
    }
  }
  Serial.println();

  // Show the sequence on the external LED (print color to Serial)
  for (int i = 0; i < SEQUENCE_LENGTH; i++) {
    switch (colorSequence[i]) {
      case 0: Serial.println("Showing RED"); break;
      case 1: Serial.println("Showing BLUE"); break;
      case 2: Serial.println("Showing GREEN"); break;
    }
    // Blink the LED for 3 seconds (250ms ON, 250ms OFF)
    unsigned long startTime = millis();
    while (millis() - startTime < 3000) {
      digitalWrite(LED_PIN, HIGH);
      delay(250);
      digitalWrite(LED_PIN, LOW);
      delay(250);
    }
    // Pause for 1 second between colors
    digitalWrite(LED_PIN, LOW);
    delay(1000);
  }
}

void loop() {
  if (!gameActive) return;

  int buttonPins[3] = {BUTTON_RED, BUTTON_BLUE, BUTTON_GREEN};
  const char* buttonNames[3] = {"Red Button Pressed", "Blue Button Pressed", "Green Button Pressed"};

  for (int i = 0; i < 3; i++) {
    int reading = digitalRead(buttonPins[i]);

    // Only act on the transition from HIGH to LOW (button press event)
    if (lastButtonState[i] == HIGH && reading == LOW && (millis() - lastDebounceTime[i]) > debounceDelay) {
      lastDebounceTime[i] = millis();

      // Print which button was pressed
      Serial.println(buttonNames[i]);

      // Game logic
      if (i == colorSequence[currentStep]) {
        currentStep++;
        if (currentStep == SEQUENCE_LENGTH) {
          Serial.println("Success");
          gameActive = false;
        }
      } else {
        Serial.println("Wrong sequence try again");
        currentStep = 0;
      }
    }
    lastButtonState[i] = reading;
  }
}
